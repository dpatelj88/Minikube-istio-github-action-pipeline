name: BookInfo CI/CD with Istio

on:
  push:
    branches:
      - main

jobs:
  MiniKube_Setup:
   name: Setup Minikube & clean up
   runs-on: self-hosted
   outputs:
    minikube_ip: ${{ steps.set-ip.outputs.minikube_ip }}
   steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Install kubectl
      run: |
        if ! command -v kubectl &> /dev/null; then
          echo "Installing kubectl..."
          curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
          chmod +x kubectl
          sudo mv kubectl /usr/local/bin/
        fi
        kubectl version --client

    - name: Start Minikube
      run: |
        if ! minikube status; then
          echo "Starting Minikube with public DNS..."
          minikube start --dns 8.8.8.8
        else
          echo "Minikube is already running. Stopping and restarting with public DNS..."
          minikube stop
          minikube start --dns 8.8.8.8
          kubectl delete all --all --namespace=default
          kubectl delete all --all -n istio-system
        fi

    - name: Fix Minikube DNS Configuration
      run: |
        echo "Fixing DNS configuration inside Minikube VM..."
        minikube ssh -- "echo 'nameserver 8.8.8.8' | sudo tee /etc/resolv.conf"
        minikube ssh -- "echo 'nameserver 8.8.4.4' | sudo tee -a /etc/resolv.conf"
        minikube ssh -- "cat /etc/resolv.conf"

    - name: Test DNS Resolution
      run: |
        echo "Testing DNS resolution inside Minikube VM..."
        minikube ssh -- "nslookup registry-1.docker.io" || echo "DNS resolution failed"

    - name: Set Minikube IP
      id: set-ip
      run: |
        MINIKUBE_IP=$(minikube ip)
        if [ -z "$MINIKUBE_IP" ]; then
          echo "ERROR: Failed to get Minikube IP"
          minikube status
          exit 1
        fi
        echo "MINIKUBE_IP=$MINIKUBE_IP" >> $GITHUB_ENV
        echo "minikube_ip=$MINIKUBE_IP" >> $GITHUB_OUTPUT
        echo "Minikube IP set to $MINIKUBE_IP"

  istioctl_install:
    runs-on: self-hosted
    needs: [MiniKube_Setup]
    env:
      MINIKUBE_IP: ${{ needs.MiniKube_Setup.outputs.minikube_ip }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Install kubectl (if not already present)
        run: |
          if ! command -v kubectl &> /dev/null; then
            echo "Installing kubectl..."
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            sudo mv kubectl /usr/local/bin/
          fi
          kubectl version --client

      - name: Check and Install Istio
        run: |
          if [ ! -d "$HOME/istio-1.25.0" ]; then
            echo "Istio not found. Downloading and installing Istio 1.25.0 to $HOME..."
            curl -LO https://github.com/istio/istio/releases/download/1.25.0/istio-1.25.0-linux-amd64.tar.gz
            tar -xzf istio-1.25.0-linux-amd64.tar.gz -C $HOME
            rm istio-1.25.0-linux-amd64.tar.gz
          else
            echo "Istio directory already exists at $HOME/istio-1.25.0"
          fi

          export PATH="$HOME/istio-1.25.0/bin:$PATH"
          echo "PATH updated: $PATH"

          if ! command -v istioctl &> /dev/null; then
            echo "ERROR: istioctl not found after setting PATH. Exiting..."
            exit 1
          fi

          if kubectl get pod -n istio-system -l app=istiod --no-headers 2>/dev/null | grep -q Running; then
            echo "Istio is already installed and running in the cluster."
          else
            echo "Installing Istio into Minikube..."
            istioctl install --set profile=demo -y
            kubectl label namespace default istio-injection=enabled --overwrite
            echo "Istio installed successfully."
          fi

  Deploy_BookInfo:
    runs-on: self-hosted
    needs: [istioctl_install]
    env:
      MINIKUBE_IP: ${{ needs.MiniKube_Setup.outputs.minikube_ip }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Deploy BookInfo App
        run: |
          export PATH="$HOME/istio-1.25.0/bin:$PATH"
          kubectl apply -f bookinfo.yaml
          kubectl apply -f bookinfo-gateway.yaml
          kubectl rollout status deployment/productpage-v1 -n default

          echo "Listing BookInfo pods:"
          kubectl get pods -n default

  deploy-monitoring:
    name: Deploy Monitoring (Grafana, Prometheus, Kiali, Jaeger, Loki)
    runs-on: self-hosted
    needs: [Deploy_BookInfo]
    env:
      MINIKUBE_IP: ${{ needs.MiniKube_Setup.outputs.minikube_ip }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Deploy Monitoring Services
        run: |
          export PATH="$HOME/istio-1.25.0/bin:$PATH"
          kubectl apply -f monitor/prometheus.yaml
          kubectl apply -f monitor/grafana.yaml
          kubectl apply -f monitor/kiali.yaml
          kubectl apply -f monitor/jaeger.yaml
          kubectl apply -f monitor/loki.yaml

          kubectl rollout status deployment/grafana -n istio-system
          kubectl rollout status deployment/prometheus -n istio-system
          kubectl rollout status deployment/kiali -n istio-system
          kubectl rollout status deployment/jaeger -n istio-system

          echo "Listing monitoring pods:"
          kubectl get pods -n istio-system -l 'app in (grafana, prometheus, kiali, jaeger)'

          echo "Monitoring tools deployed. Use port-forwarding to access dashboards."
